// src/main.rs - woflOS kernel entry point
#![no_std]
#![no_main]

mod uart;
mod memory;
mod interrupts;

use core::panic::PanicInfo;
use uart::Uart;

// Global UART instance
static mut UART: Option<Uart> = None;

// Helper to get UART
fn uart() -> &'static Uart {
    unsafe { UART.as_ref().unwrap() }
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    unsafe {
        if let Some(uart) = UART.as_ref() {
            uart.puts("\n[PANIC] ");
            uart.puts("Kernel panic!\n");
        }
    }
    loop {}
}

/// Kernel entry point called from assembly
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    // Initialize UART first
    unsafe {
        UART = Some(Uart::new(0x1000_0000));
    }
    
    uart().puts("\n============================================\n");
    uart().puts("  Stability    Security    Performance\n\n");
    uart().puts("   __      __ ___  ____  _     ___    ____\n");
    uart().puts(" \\ \\    / // _ \\| ___|| |   / _ \\  /  _|\n");
    uart().puts("  \\ \\/\\/ /| (_) | __| | |__| (_) | _\\ \\\n");
    uart().puts("   \\_/\\_/  \\___/|_|   |____|\\___/ |___/\n");
    uart().puts("\n      Rust + RISC-V + Microkernel\n");
    uart().puts("============================================\n\n");
    
    uart().puts("[OK] woflOS v0.4.0 booting...\n");
    uart().puts("[OK] UART initialized\n");
    uart().puts("[OK] BSS cleared\n");
    
    // Initialize memory
    unsafe {
        extern "C" {
            fn _end();
        }
        let kernel_end = _end as usize;
        let memory_end = 0x8800_0000; // 128MB for QEMU
        memory::init(kernel_end, memory_end);
    }
    uart().puts("[OK] Memory manager initialized\n");
    
    // Initialize trap handling and enable interrupts
    interrupts::trap::init();
    
    uart().puts("\n[OK] Kernel is running with interrupts enabled!\n");
    uart().puts("[OK] You should see timer ticks appearing...\n\n");
    
    // Test the heap allocator
    test_heap();
    
    // Idle loop - interrupts will fire in the background
    uart().puts("\n[OK] Entering idle loop...\n");
    uart().puts("[OK] Timer interrupts should continue firing.\n\n");
    
    loop {
        // Wait for interrupt
        unsafe {
            core::arch::asm!("wfi");
        }
    }
}

fn test_heap() {
    extern crate alloc;
    use alloc::vec::Vec;
    
    uart().puts("[TEST] Testing heap allocator...\n");
    
    let mut v = Vec::new();
    v.push(42);
    v.push(1337);
    
    uart().puts("[OK] Heap allocation works!\n");
}